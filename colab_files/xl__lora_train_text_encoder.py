# -*- coding: utf-8 -*-
"""XL__LORA_Train_Text_Encoder.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sBmHFfLIq4gc4wIsRVNIHbw3bVgaXf4L
"""

!git clone https://github.com/huggingface/diffusers
# %cd diffusers
# %pip install .
# %cd examples/dreambooth
# %pip install -r requirements.txt
!pip install git+https://github.com/huggingface/diffusers.git -q

from accelerate.utils import write_basic_config

write_basic_config()



# Install dependencies.
!pip install bitsandbytes transformers accelerate peft -q
!wget https://raw.githubusercontent.com/huggingface/diffusers/main/examples/dreambooth/train_dreambooth_lora_sdxl.py

# import locale
# locale.getpreferredencoding = lambda: "UTF-8"

!accelerate config default
!pip install datasets -q
import numpy as np

from google.colab import drive

drive.mount('/content/drive/')
train_dir = '.'
!cp -r /content/drive/MyDrive/trainingSet/StableDiffusion/small_data.zip .
!unzip small_data.zip -d .

save_dir = './weights/'
logs_dir ='./lightning_logs/'
import os
if not os.path.exists(save_dir):
  os.mkdir(save_dir)

if not os.path.exists(logs_dir):
  os.mkdir(logs_dir)

import argparse
import gc
import itertools
import json
import logging
import math
import os
import random
import shutil
import warnings
from contextlib import nullcontext
from pathlib import Path

import numpy as np
import torch
import torch.nn.functional as F
import torch.utils.checkpoint
import transformers
from accelerate import Accelerator
from accelerate.logging import get_logger
from accelerate.utils import DistributedDataParallelKwargs, ProjectConfiguration, set_seed
from huggingface_hub import create_repo, hf_hub_download, upload_folder
from huggingface_hub.utils import insecure_hashlib
from packaging import version
from peft import LoraConfig, set_peft_model_state_dict
from peft.utils import get_peft_model_state_dict
from PIL import Image
from PIL.ImageOps import exif_transpose
from safetensors.torch import load_file, save_file
from torch.utils.data import Dataset
from torchvision import transforms
from torchvision.transforms.functional import crop
from tqdm.auto import tqdm
from transformers import AutoTokenizer, PretrainedConfig

import diffusers
from diffusers import (
    AutoencoderKL,
    DDPMScheduler,
    DPMSolverMultistepScheduler,
    EDMEulerScheduler,
    EulerDiscreteScheduler,
    StableDiffusionXLPipeline,
    UNet2DConditionModel,
)
from diffusers.loaders import StableDiffusionLoraLoaderMixin
from diffusers.optimization import get_scheduler
from diffusers.training_utils import _set_state_dict_into_text_encoder, cast_training_params, compute_snr
from diffusers.utils import (
    check_min_version,
    convert_all_state_dict_to_peft,
    convert_state_dict_to_diffusers,
    convert_state_dict_to_kohya,
    convert_unet_state_dict_to_peft,
    is_peft_version,
    is_wandb_available,
)
from diffusers.utils.hub_utils import load_or_create_model_card, populate_model_card
from diffusers.utils.import_utils import is_xformers_available
from diffusers.utils.torch_utils import is_compiled_module


def determine_scheduler_type(pretrained_model_name_or_path, revision):
    model_index_filename = "model_index.json"
    if os.path.isdir(pretrained_model_name_or_path):
        model_index = os.path.join(pretrained_model_name_or_path, model_index_filename)
    else:
        model_index = hf_hub_download(
            repo_id=pretrained_model_name_or_path, filename=model_index_filename
        )

    with open(model_index, "r") as f:
        scheduler_type = json.load(f)["scheduler"][1]
    return scheduler_type


def save_model_card(
    repo_id: str,
    use_dora: bool,
    images=None,
    base_model: str = None,
    train_text_encoder=False,
    instance_prompt=None,
    validation_prompt=None,
    repo_folder=None,
    vae_path=None,
):
    widget_dict = []
    if images is not None:
        for i, image in enumerate(images):
            image.save(os.path.join(repo_folder, f"image_{i}.png"))
            widget_dict.append(
                {"text": validation_prompt if validation_prompt else " ", "output": {"url": f"image_{i}.png"}}
            )

    model_description = f"""
# {'SDXL' if 'playground' not in base_model else 'Playground'} LoRA DreamBooth - {repo_id}

<Gallery />

## Model description

These are {repo_id} LoRA adaption weights for {base_model}.

The weights were trained  using [DreamBooth](https://dreambooth.github.io/).

LoRA for the text encoder was enabled: {train_text_encoder}.

Special VAE used for training: {vae_path}.

## Trigger words

You should use {instance_prompt} to trigger the image generation.

## Download model

Weights for this model are available in Safetensors format.

[Download]({repo_id}/tree/main) them in the Files & versions tab.

"""
    if "playground" in base_model:
        model_description += """\n
## License

Please adhere to the licensing terms as described [here](https://huggingface.co/playgroundai/playground-v2.5-1024px-aesthetic/blob/main/LICENSE.md).
"""
    model_card = load_or_create_model_card(
        repo_id_or_path=repo_id,
        from_training=True,
        license="openrail++" if "playground" not in base_model else "playground-v2dot5-community",
        base_model=base_model,
        prompt=instance_prompt,
        model_description=model_description,
        widget=widget_dict,
    )
    tags = [
        "text-to-image",
        "text-to-image",
        "diffusers-training",
        "diffusers",
        "lora" if not use_dora else "dora",
        "template:sd-lora",
    ]
    if "playground" in base_model:
        tags.extend(["playground", "playground-diffusers"])
    else:
        tags.extend(["stable-diffusion-xl", "stable-diffusion-xl-diffusers"])

    model_card = populate_model_card(model_card, tags=tags)
    model_card.save(os.path.join(repo_folder, "README.md"))


def log_validation(
    pipeline,
    args,
    accelerator,
    pipeline_args,
    epoch,
    torch_dtype,
    is_final_validation=False,
):
    logger.info(
        f"Running validation... \n Generating {args.num_validation_images} images with prompt:"
        f" {args.validation_prompt}."
    )

    # We train on the simplified learning objective. If we were previously predicting a variance, we need the scheduler to ignore it
    scheduler_args = {}

    if not args.do_edm_style_training:
        if "variance_type" in pipeline.scheduler.config:
            variance_type = pipeline.scheduler.config.variance_type

            if variance_type in ["learned", "learned_range"]:
                variance_type = "fixed_small"

            scheduler_args["variance_type"] = variance_type

        pipeline.scheduler = DPMSolverMultistepScheduler.from_config(pipeline.scheduler.config, **scheduler_args)

    pipeline = pipeline.to(accelerator.device, dtype=torch_dtype)
    pipeline.set_progress_bar_config(disable=True)

    # run inference
    generator = torch.Generator(device=accelerator.device).manual_seed(args.seed) if args.seed else None
    # Currently the context determination is a bit hand-wavy. We can improve it in the future if there's a better
    # way to condition it. Reference: https://github.com/huggingface/diffusers/pull/7126#issuecomment-1968523051
    if torch.backends.mps.is_available() or "playground" in args.pretrained_model_name_or_path:
        autocast_ctx = nullcontext()
    else:
        autocast_ctx = torch.autocast(accelerator.device.type)

    with autocast_ctx:
        images = [pipeline(**pipeline_args, generator=generator).images[0] for _ in range(args.num_validation_images)]

    for tracker in accelerator.trackers:
        phase_name = "test" if is_final_validation else "validation"
        if tracker.name == "tensorboard":
            np_images = np.stack([np.asarray(img) for img in images])
            tracker.writer.add_images(phase_name, np_images, epoch, dataformats="NHWC")
        if tracker.name == "wandb":
            tracker.log(
                {
                    phase_name: [
                        wandb.Image(image, caption=f"{i}: {args.validation_prompt}") for i, image in enumerate(images)
                    ]
                }
            )

    del pipeline
    if torch.cuda.is_available():
        torch.cuda.empty_cache()

    return images


def import_model_class_from_model_name_or_path(
    pretrained_model_name_or_path: str, revision: str, subfolder: str = "text_encoder"
):
    text_encoder_config = PretrainedConfig.from_pretrained(
        pretrained_model_name_or_path, subfolder=subfolder,
    )
    model_class = text_encoder_config.architectures[0]

    if model_class == "CLIPTextModel":
        from transformers import CLIPTextModel

        return CLIPTextModel
    elif model_class == "CLIPTextModelWithProjection":
        from transformers import CLIPTextModelWithProjection

        return CLIPTextModelWithProjection
    else:
        raise ValueError(f"{model_class} is not supported.")

class PromptDataset(Dataset):
    """A simple dataset to prepare the prompts to generate class images on multiple GPUs."""

    def __init__(self, prompt, num_samples):
        self.prompt = prompt
        self.num_samples = num_samples

    def __len__(self):
        return self.num_samples

    def __getitem__(self, index):
        example = {}
        example["prompt"] = self.prompt
        example["index"] = index
        return example


def tokenize_prompt(tokenizer, prompt):
    text_inputs = tokenizer(
        prompt,
        padding="max_length",
        max_length=tokenizer.model_max_length,
        truncation=True,
        return_tensors="pt",
    )
    text_input_ids = text_inputs.input_ids
    return text_input_ids



def encode_prompt(batch, text_encoders, tokenizers, proportion_empty_prompts, caption_column, is_train=True):
    prompt_embeds_list = []
    prompt_batch = batch[caption_column]

    captions = []
    for caption in prompt_batch:
        if random.random() < proportion_empty_prompts:
            captions.append("")
        elif isinstance(caption, str):
            captions.append(caption)
        elif isinstance(caption, (list, np.ndarray)):
            # take a random caption if there are multiple
            captions.append(random.choice(caption) if is_train else caption[0])

    with torch.no_grad():
        for tokenizer, text_encoder in zip(tokenizers, text_encoders):
            text_inputs = tokenizer(
                captions,
                padding="max_length",
                max_length=tokenizer.model_max_length,
                truncation=True,
                return_tensors="pt",
            )
            text_input_ids = text_inputs.input_ids
            prompt_embeds = text_encoder(
                text_input_ids.to(text_encoder.device),
                output_hidden_states=True,
                return_dict=False,
            )

            # We are only ALWAYS interested in the pooled output of the final text encoder
            # aici 1
            pooled_prompt_embeds = prompt_embeds[0]
            prompt_embeds = prompt_embeds[-1][-2]
            bs_embed, seq_len, _ = prompt_embeds.shape
            prompt_embeds = prompt_embeds.view(bs_embed, seq_len, -1)
            prompt_embeds_list.append(prompt_embeds)

    prompt_embeds = torch.concat(prompt_embeds_list, dim=-1)
    pooled_prompt_embeds = pooled_prompt_embeds.view(bs_embed, -1)
    return {"prompt_embeds": prompt_embeds.cpu(), "pooled_prompt_embeds": pooled_prompt_embeds.cpu()}

args = {
"pretrained_model_name_or_path":"stabilityai/stable-diffusion-xl-base-1.0" ,
"pretrained_vae_model_name_or_path":"madebyollin/sdxl-vae-fp16-fix" ,
"dataset_name":"'newData" ,
"dataset_config_name":"./content/newData/shareMAOmetadata.jsonl" ,
"output_dir":"Stable_DIFF_Gabi_XL" ,
"caption_column":"caption",
"image_column":"file_name",
"mixed_precision":"fp16" ,
# "instance_prompt":"jasminejae face" ,
"resolutionH": 1280,
"resolutionW": 960,
"logging_dir": "/log",
"dataloader_num_workers":8,
"train_batch_size":1 ,
"gradient_accumulation_steps":3 ,
"gradient_checkpointing":True ,
"learning_rate":1e-4 ,
"snr_gamma":5.0 ,
"lr_scheduler":"constant" ,
"lr_warmup_steps":0 ,
"mixed_precision":"fp16" ,
"use_8bit_adam":True ,
"max_train_steps":6750 ,
"checkpointing_steps":717 ,
"seed":0,
        "adam_beta1":0.9,
        "adam_beta2": 0.999,
        "adam_weight_decay": 1e-2,
        "adam_epsilon": 1e-08,
        "max_grad_norm": 1.0,
        "rank":4,
        "revision":"main" ,
         "use_dora":False,
         "scale_lr":False,
         "optimizer":"AdamW",
         "lr_warmup_steps":500,
         "lr_num_cycles":1,
         "lr_power":0,
         "train_text_encoder" : True,
         "adam_weight_decay_text_encoder":1e-03,
          "text_encoder_lr":5e-6,
         "num_train_epochs" : 30,
         "checkpoints_total_limit":10
}

logger = get_logger(__name__)

if args.get("do_edm_style_training") and args["snr_gamma"] is not None:
    raise ValueError("Min-SNR formulation is not supported when conducting EDM-style training.")

if torch.backends.mps.is_available() and args["mixed_precision"] == "bf16":
    # due to pytorch#99272, MPS does not yet support bfloat16.
    raise ValueError(
        "Mixed precision training with bfloat16 is not supported on MPS. Please use fp16 (recommended) or fp32 instead."
    )
logging_dir = Path(args["output_dir"], args["logging_dir"])

accelerator_project_config = ProjectConfiguration(project_dir=args["output_dir"], logging_dir=logging_dir)
kwargs = DistributedDataParallelKwargs(find_unused_parameters=True)
accelerator = Accelerator(
    gradient_accumulation_steps=args["gradient_accumulation_steps"],
    mixed_precision=args["mixed_precision"],
    log_with=args.get("report_to"),
    project_config=accelerator_project_config,
    kwargs_handlers=[kwargs],
)

# Disable AMP for MPS.
if torch.backends.mps.is_available():
    accelerator.native_amp = False

if args.get("report_to") == "wandb":
    if not is_wandb_available():
        raise ImportError("Make sure to install wandb if you want to use it for logging during training.")

# Make one log on every process with the configuration for debugging.
logging.basicConfig(
    format="%(asctime)s - %(levelname)s - %(name)s - %(message)s",
    datefmt="%m/%d/%Y %H:%M:%S",
    level=logging.INFO,
)
logger.info(accelerator.state, main_process_only=False)
if accelerator.is_local_main_process:
    transformers.utils.logging.set_verbosity_warning()
    diffusers.utils.logging.set_verbosity_info()
else:
    transformers.utils.logging.set_verbosity_error()
    diffusers.utils.logging.set_verbosity_error()

# If passed along, set the training seed now.
if args["seed"] is not None:
    set_seed(args["seed"])

# Generate class images if prior preservation is enabled.
if args.get("with_prior_preservation"):
    class_images_dir = Path(args["class_data_dir"])
    if not class_images_dir.exists():
        class_images_dir.mkdir(parents=True)
    cur_class_images = len(list(class_images_dir.iterdir()))

    if cur_class_images < args["num_class_images"]:
        has_supported_fp16_accelerator = torch.cuda.is_available() or torch.backends.mps.is_available()
        torch_dtype = torch.float16 if has_supported_fp16_accelerator else torch.float32
        if args["prior_generation_precision"] == "fp32":
            torch_dtype = torch.float32
        elif args["prior_generation_precision"] == "fp16":
            torch_dtype = torch.float16
        elif args["prior_generation_precision"] == "bf16":
            torch_dtype = torch.bfloat16
        pipeline = StableDiffusionXLPipeline.from_pretrained(
            args["pretrained_model_name_or_path"],
            torch_dtype=torch_dtype,


        )
        pipeline.set_progress_bar_config(disable=True)

        num_new_images = args["num_class_images"] - cur_class_images
        logger.info(f"Number of class images to sample: {num_new_images}.")

        sample_dataset = PromptDataset(args["class_prompt"], num_new_images)
        sample_dataloader = torch.utils.data.DataLoader(sample_dataset, batch_size=args["sample_batch_size"])

        sample_dataloader = accelerator.prepare(sample_dataloader)
        pipeline.to(accelerator.device)

        for example in tqdm(
            sample_dataloader, desc="Generating class images", disable=not accelerator.is_local_main_process
        ):
            images = pipeline(example["prompt"]).images

            for i, image in enumerate(images):
                hash_image = insecure_hashlib.sha1(image.tobytes()).hexdigest()
                image_filename = class_images_dir / f"{example['index'][i] + cur_class_images}-{hash_image}.jpg"
                image.save(image_filename)

        del pipeline
        if torch.cuda.is_available():
            torch.cuda.empty_cache()

# Handle the repository creation
if accelerator.is_main_process:
    if args["output_dir"] is not None:
        os.makedirs(args["output_dir"], exist_ok=True)

# Load the tokenizers
tokenizer_one = AutoTokenizer.from_pretrained(
    args["pretrained_model_name_or_path"],
    subfolder="tokenizer",
    use_fast=False,
)
tokenizer_two = AutoTokenizer.from_pretrained(
    args["pretrained_model_name_or_path"],
    subfolder="tokenizer_2",
    use_fast=False,
)

# import correct text encoder classes
text_encoder_cls_one = import_model_class_from_model_name_or_path(
    args["pretrained_model_name_or_path"], args["revision"]
)
text_encoder_cls_two = import_model_class_from_model_name_or_path(
    args["pretrained_model_name_or_path"], args["revision"], subfolder="text_encoder_2"
)

# Load scheduler and models
scheduler_type = determine_scheduler_type(args["pretrained_model_name_or_path"], args["revision"])
if "EDM" in scheduler_type:
    args.get("do_edm_style_training") == True
    noise_scheduler = EDMEulerScheduler.from_pretrained(args["pretrained_model_name_or_path"], subfolder="scheduler")
    logger.info("Performing EDM-style training!")
elif args.get("do_edm_style_training"):
    noise_scheduler = EulerDiscreteScheduler.from_pretrained(
        args["pretrained_model_name_or_path"], subfolder="scheduler"
    )
    logger.info("Performing EDM-style training!")
else:
    noise_scheduler = DDPMScheduler.from_pretrained(args["pretrained_model_name_or_path"], subfolder="scheduler")

text_encoder_one = text_encoder_cls_one.from_pretrained(
    args["pretrained_model_name_or_path"], subfolder="text_encoder"
  )
text_encoder_two = text_encoder_cls_two.from_pretrained(
    args["pretrained_model_name_or_path"], subfolder="text_encoder_2"
  )
vae_path = (
    args["pretrained_model_name_or_path"]
    if args["pretrained_vae_model_name_or_path"] is None
    else args["pretrained_vae_model_name_or_path"]
)
vae = AutoencoderKL.from_pretrained(
    vae_path,
    subfolder="vae" if args["pretrained_vae_model_name_or_path"] is None else None,


)
latents_mean = latents_std = None
if hasattr(vae.config, "latents_mean") and vae.config.latents_mean is not None:
    latents_mean = torch.tensor(vae.config.latents_mean).view(1, 4, 1, 1)
if hasattr(vae.config, "latents_std") and vae.config.latents_std is not None:
    latents_std = torch.tensor(vae.config.latents_std).view(1, 4, 1, 1)

unet = UNet2DConditionModel.from_pretrained(
    args["pretrained_model_name_or_path"], subfolder="unet",
)

# We only train the additional adapter LoRA layers
vae.requires_grad_(False)
text_encoder_one.requires_grad_(False)
text_encoder_two.requires_grad_(False)
unet.requires_grad_(False)

# For mixed precision training we cast all non-trainable weights (vae, non-lora text_encoder and non-lora unet) to half-precision
# as these weights are only used for inference, keeping weights in full precision is not required.
weight_dtype = torch.float32
if accelerator.mixed_precision == "fp16":
    weight_dtype = torch.float16
elif accelerator.mixed_precision == "bf16":
    weight_dtype = torch.bfloat16

if torch.backends.mps.is_available() and weight_dtype == torch.bfloat16:
    # due to pytorch#99272, MPS does not yet support bfloat16.
    raise ValueError(
        "Mixed precision training with bfloat16 is not supported on MPS. Please use fp16 (recommended) or fp32 instead."
    )

# Move unet, vae and text_encoder to device and cast to weight_dtype
unet.to(accelerator.device, dtype=weight_dtype)

# The VAE is always in float32 to avoid NaN losses.
vae.to(accelerator.device, dtype=torch.float32)

text_encoder_one.to(accelerator.device, dtype=weight_dtype)
text_encoder_two.to(accelerator.device, dtype=weight_dtype)

if args.get("enable_xformers_memory_efficient_attention"):
    if is_xformers_available():
        import xformers

        xformers_version = version.parse(xformers.__version__)
        if xformers_version == version.parse("0.0.16"):
            logger.warning(
                "xFormers 0.0.16 cannot be used for training in some GPUs. If you observe problems during training, "
                "please update xFormers to at least 0.0.17. See https://huggingface.co/docs/diffusers/main/en/optimization/xformers for more details."
            )
        unet.enable_xformers_memory_efficient_attention()
    else:
        raise ValueError("xformers is not available. Make sure it is installed correctly")

if args["gradient_checkpointing"]:
    unet.enable_gradient_checkpointing()
    if args.get("train_text_encoder") ==True:
        text_encoder_one.gradient_checkpointing_enable()
        text_encoder_two.gradient_checkpointing_enable()

def get_lora_config(rank, use_dora, target_modules):
    base_config = {
        "r": rank,
        "lora_alpha": rank,
        "init_lora_weights": "gaussian",
        "target_modules": target_modules,
    }
    if use_dora:
        if is_peft_version("<", "0.9.0"):
            raise ValueError(
                "You need `peft` 0.9.0 at least to use DoRA-enabled LoRAs. Please upgrade your installation of `peft`."
            )
        else:
            base_config["use_dora"] = True

    return LoraConfig(**base_config)

# now we will add new LoRA weights to the attention layers
unet_target_modules = ["to_k", "to_q", "to_v", "to_out.0"]
unet_lora_config = get_lora_config(rank=args["rank"], use_dora=args["use_dora"], target_modules=unet_target_modules)
unet.add_adapter(unet_lora_config)

# The text encoder comes from ðŸ¤— transformers, so we cannot directly modify it.
# So, instead, we monkey-patch the forward calls of its attention-blocks.
if args.get("train_text_encoder") == True:
    text_target_modules = ["q_proj", "k_proj", "v_proj", "out_proj"]
    text_lora_config = get_lora_config(rank=args["rank"], use_dora=args["use_dora"], target_modules=text_target_modules)
    text_encoder_one.add_adapter(text_lora_config)
    text_encoder_two.add_adapter(text_lora_config)

def unwrap_model(model):
    model = accelerator.unwrap_model(model)
    model = model._orig_mod if is_compiled_module(model) else model
    return model

# create custom saving & loading hooks so that `accelerator.save_state(...)` serializes in a nice format
def save_model_hook(models, weights, output_dir):
    if accelerator.is_main_process:
        # there are only two options here. Either are just the unet attn processor layers
        # or there are the unet and text encoder atten layers
        unet_lora_layers_to_save = None
        text_encoder_one_lora_layers_to_save = None
        text_encoder_two_lora_layers_to_save = None

        for model in models:
            if isinstance(model, type(unwrap_model(unet))):
                unet_lora_layers_to_save = convert_state_dict_to_diffusers(get_peft_model_state_dict(model))
            elif isinstance(model, type(unwrap_model(text_encoder_one))):
                text_encoder_one_lora_layers_to_save = convert_state_dict_to_diffusers(
                    get_peft_model_state_dict(model)
                )
            elif isinstance(model, type(unwrap_model(text_encoder_two))):
                text_encoder_two_lora_layers_to_save = convert_state_dict_to_diffusers(
                    get_peft_model_state_dict(model)
                )
            else:
                raise ValueError(f"unexpected save model: {model.__class__}")

            # make sure to pop weight so that corresponding model is not saved again
            weights.pop()

        StableDiffusionXLPipeline.save_lora_weights(
            output_dir,
            unet_lora_layers=unet_lora_layers_to_save,
            text_encoder_lora_layers=text_encoder_one_lora_layers_to_save,
            text_encoder_2_lora_layers=text_encoder_two_lora_layers_to_save,
        )

def load_model_hook(models, input_dir):
    unet_ = None
    text_encoder_one_ = None
    text_encoder_two_ = None

    while len(models) > 0:
        model = models.pop()

        if isinstance(model, type(unwrap_model(unet))):
            unet_ = model
        elif isinstance(model, type(unwrap_model(text_encoder_one))):
            text_encoder_one_ = model
        elif isinstance(model, type(unwrap_model(text_encoder_two))):
            text_encoder_two_ = model
        else:
            raise ValueError(f"unexpected save model: {model.__class__}")

    lora_state_dict, network_alphas = StableDiffusionLoraLoaderMixin.lora_state_dict(input_dir)

    unet_state_dict = {f'{k.replace("unet.", "")}': v for k, v in lora_state_dict.items() if k.startswith("unet.")}
    unet_state_dict = convert_unet_state_dict_to_peft(unet_state_dict)
    incompatible_keys = set_peft_model_state_dict(unet_, unet_state_dict, adapter_name="default")
    if incompatible_keys is not None:
        # check only for unexpected keys
        unexpected_keys = getattr(incompatible_keys, "unexpected_keys", None)
        if unexpected_keys:
            logger.warning(
                f"Loading adapter weights from state_dict led to unexpected keys not found in the model: "
                f" {unexpected_keys}. "
            )

    if args.get("train_text_encoder") ==True:
        # Do we need to call `scale_lora_layers()` here?
        _set_state_dict_into_text_encoder(lora_state_dict, prefix="text_encoder.", text_encoder=text_encoder_one_)

        _set_state_dict_into_text_encoder(
            lora_state_dict, prefix="text_encoder_2.", text_encoder=text_encoder_two_
        )

    # Make sure the trainable params are in float32. This is again needed since the base models
    # are in `weight_dtype`. More details:
    # https://github.com/huggingface/diffusers/pull/6514#discussion_r1449796804
    if args["mixed_precision"] == "fp16":
        models = [unet_]
        if args.get("train_text_encoder")==True:
            models.extend([text_encoder_one_, text_encoder_two_])
        # only upcast trainable parameters (LoRA) into fp32
        cast_training_params(models)

accelerator.register_save_state_pre_hook(save_model_hook)
accelerator.register_load_state_pre_hook(load_model_hook)

# Enable TF32 for faster training on Ampere GPUs,
# cf https://pytorch.org/docs/stable/notes/cuda.html#tensorfloat-32-tf32-on-ampere-devices
if args.get("allow_tf32") and torch.cuda.is_available():
    torch.backends.cuda.matmul.allow_tf32 = True

if args["scale_lr"]:
    args["learning_rate"] = (
        args["learning_rate"] * args["gradient_accumulation_steps"] * args["train_batch_size"] * accelerator.num_processes
    )

# Make sure the trainable params are in float32.
if args["mixed_precision"] == "fp16":
    models = [unet]
    if args.get("train_text_encoder") ==True:
        models.extend([text_encoder_one, text_encoder_two])

    # only upcast trainable parameters (LoRA) into fp32
    cast_training_params(models, dtype=torch.float32)

unet_lora_parameters = list(filter(lambda p: p.requires_grad, unet.parameters()))

if args.get("train_text_encoder") ==True:
    text_lora_parameters_one = list(filter(lambda p: p.requires_grad, text_encoder_one.parameters()))
    text_lora_parameters_two = list(filter(lambda p: p.requires_grad, text_encoder_two.parameters()))

# Optimization parameters
unet_lora_parameters_with_lr = {"params": unet_lora_parameters, "lr": args["learning_rate"]}
if args.get("train_text_encoder")== True:
    # different learning rate for text encoder and unet
    text_lora_parameters_one_with_lr = {
        "params": text_lora_parameters_one,
        "weight_decay": args["adam_weight_decay_text_encoder"],
        "lr": args["text_encoder_lr"] if args["text_encoder_lr"] else args["learning_rate"],
    }
    text_lora_parameters_two_with_lr = {
        "params": text_lora_parameters_two,
        "weight_decay": args["adam_weight_decay_text_encoder"],
        "lr": args["text_encoder_lr"] if args["text_encoder_lr"] else args["learning_rate"],
    }
    params_to_optimize = [
        unet_lora_parameters_with_lr,
        text_lora_parameters_one_with_lr,
        text_lora_parameters_two_with_lr,
    ]
else:
    params_to_optimize = [unet_lora_parameters_with_lr]

# Optimizer creation
if not (args["optimizer"].lower() == "prodigy" or args["optimizer"].lower() == "adamw"):
    logger.warning(
        f"Unsupported choice of optimizer: {args['optimizer']}.Supported optimizers include [adamW, prodigy]."
        "Defaulting to adamW"
    )
    args["optimizer"] = "adamw"

if args["use_8bit_adam"] and not args["optimizer"].lower() == "adamw":
    logger.warning(
        f"use_8bit_adam is ignored when optimizer is not set to 'AdamW'. Optimizer was "
        f"set to {args['optimizer'].lower()}"
    )

if args["optimizer"].lower() == "adamw":
    if args["use_8bit_adam"]:
        try:
            import bitsandbytes as bnb
        except ImportError:
            raise ImportError(
                "To use 8-bit Adam, please install the bitsandbytes library: `pip install bitsandbytes`."
            )

        optimizer_class = bnb.optim.AdamW8bit
    else:
        optimizer_class = torch.optim.AdamW

    optimizer = optimizer_class(
        params_to_optimize,
        betas=(args["adam_beta1"], args["adam_beta2"]),
        weight_decay=args["adam_weight_decay"],
        eps=args["adam_epsilon"],
    )

if args["optimizer"].lower() == "prodigy":
    try:
        import prodigyopt
    except ImportError:
        raise ImportError("To use Prodigy, please install the prodigyopt library: `pip install prodigyopt`")

    optimizer_class = prodigyopt.Prodigy

    if args["learning_rate"] <= 0.1:
        logger.warning(
            "Learning rate is too low. When using prodigy, it's generally better to set learning rate around 1.0"
        )
    if args.get("train_text_encoder") ==True  and args["text_encoder_lr"] is not None:
        logger.warning(
            f"Learning rates were provided both for the unet and the text encoder- e.g. text_encoder_lr:"
            f" {args['text_encoder_lr']} and learning_rate: {args['learning_rate']}. "
            f"When using prodigy only learning_rate is used as the initial learning rate."
        )
        # changes the learning rate of text_encoder_parameters_one and text_encoder_parameters_two to be
        # --learning_rate
        params_to_optimize[1]["lr"] = args["learning_rate"]
        params_to_optimize[2]["lr"] = args["learning_rate"]

    optimizer = optimizer_class(
        params_to_optimize,
        betas=(args["adam_beta1"], args["adam_beta2"]),
        beta3=args["prodigy_beta3"],
        weight_decay=args["adam_weight_decay"],
        eps=args["adam_epsilon"],
        decouple=args["prodigy_decouple"],
        use_bias_correction=args["prodigy_use_bias_correction"],
        safeguard_warmup=args["prodigy_safeguard_warmup"],
    )

"""dataset"""

import pandas as pd
from datasets import Dataset
import datasets
import functools
from torchvision.io import read_image, ImageReadMode
from datasets import concatenate_datasets


df1 = pd.read_csv('./small_data/captioned_With_ai.csv',sep='\t')


df2 = df1[ df1['caption'].str.contains('pot_ki', case = False) ]
df3 = df1[ df1['caption'].str.contains('sandy', case = False) ]
df4 = pd.concat((df2,df3))
df4 =df4.drop('Unnamed: 0', axis=1)

df4.reset_index(drop=True, inplace=True)
dataset = datasets.Dataset.from_pandas(df4)

train_resize = transforms.Resize((args["resolutionH"] , args["resolutionW"]), interpolation=transforms.InterpolationMode.BILINEAR)
train_crop = transforms.CenterCrop((args["resolutionH"] , args["resolutionW"]),) if "center_crop" in args else transforms.RandomCrop(
    (args["resolutionH"] , args["resolutionW"]))
train_flip = transforms.RandomHorizontalFlip(p=1.0)
# train_transforms = transforms.Compose([transforms.ToTensor(), transforms.Normalize([0.5], [0.5])])
train_transforms = transforms.Compose([
    transforms.ToPILImage(),
    # transforms.Resize((1280, 960), interpolation=transforms.InterpolationMode.BILINEAR),
    # transforms.CenterCrop(args.resolution) if args.center_crop else transforms.RandomCrop(args.resolution),
    # transforms.RandomHorizontalFlip() if args.random_flip else transforms.Lambda(lambda x: x),
    transforms.ToTensor(),
    transforms.Normalize([0.5], [0.5])
    ]
)
def compute_vae_encodings(batch, vae):
    images = batch.pop("pixel_values")
    pixel_values = torch.stack(list(images))
    pixel_values = pixel_values.to(memory_format=torch.contiguous_format).float()
    pixel_values = pixel_values.to(vae.device, dtype=vae.dtype)

    with torch.no_grad():
        model_input = vae.encode(pixel_values).latent_dist.sample()
    model_input = model_input * vae.config.scaling_factor

    # There might have slightly performance improvement
    # by changing model_input.cpu() to accelerator.gather(model_input)
    return {"model_input": model_input.cpu()}

def collate_fn(examples):
  model_input = torch.stack([torch.tensor(example["model_input"]) for example in examples])
  original_sizes = [example["original_sizes"] for example in examples]
  crop_top_lefts = [example["crop_top_lefts"] for example in examples]
  prompt_embeds = torch.stack([torch.tensor(example["prompt_embeds"]) for example in examples])
  pooled_prompt_embeds = torch.stack([torch.tensor(example["pooled_prompt_embeds"]) for example in examples])
  return {
      "model_input": model_input,
      "prompt_embeds": prompt_embeds,
      "pooled_prompt_embeds": pooled_prompt_embeds,
      "original_sizes": original_sizes,
      "crop_top_lefts": crop_top_lefts,
  }


def preprocess_train(examples):
    image_paths = [path for path in examples["path"]]
    image_numbers = [no for no in examples["no"]]
    images = [read_image(image_path, mode=ImageReadMode.RGB) for image_path in image_paths]
    captions = [x for x in  examples["caption"] ]
    # image aug
    original_sizes = []
    all_images = []
    crop_top_lefts = []
    for image in images:
        original_sizes.append((image.shape[1], image.shape[2]))
        image = train_resize(image)
        if "random_flip" in args  and random.random() < 0.5:
            # flip
            image = train_flip(image)
        if "center_crop" in args:
            y1 = max(0, int(round((image.height - args["resolutionH"]) / 2.0)))
            x1 = max(0, int(round((image.width -  args["resolutionW"]) / 2.0)))
            image = train_crop(image)
        else:
            y1, x1, h, w = train_crop.get_params(image, (args["resolutionH"], args["resolutionW"]))
            image = crop(image, y1, x1, h, w)
        crop_top_left = (y1, x1)
        crop_top_lefts.append(crop_top_left)
        image = train_transforms(image)
        all_images.append(image)

    examples["original_sizes"] = original_sizes
    examples["crop_top_lefts"] = crop_top_lefts
    examples["pixel_values"] = all_images
    examples["captions"] = captions
    return examples

with accelerator.main_process_first():
    train_dataset = dataset.with_transform(preprocess_train)

    # Let's first compute all the embeddings so that we can free up the text encoders
    # from memory. We will pre-compute the VAE encodings too.
text_encoders = [text_encoder_one, text_encoder_two]
tokenizers = [tokenizer_one, tokenizer_two]
compute_embeddings_fn = functools.partial(
    encode_prompt,
    text_encoders=text_encoders,
    tokenizers=tokenizers,
    proportion_empty_prompts=0,
    caption_column = "captions"
)
compute_vae_encodings_fn = functools.partial(compute_vae_encodings, vae=vae)
with accelerator.main_process_first():
    from datasets.fingerprint import Hasher

    # fingerprint used by the cache for the other processes to load the result
    # details: https://github.com/huggingface/diffusers/pull/4038#discussion_r1266078401
    new_fingerprint = Hasher.hash(args)
    new_fingerprint_for_vae = Hasher.hash((vae_path, args))
    train_dataset_with_embeddings = train_dataset.map(
        compute_embeddings_fn, batched=True, new_fingerprint=new_fingerprint
    )
    train_dataset_with_vae = train_dataset.map(
        compute_vae_encodings_fn,
        batched=True,
        batch_size=args["train_batch_size"],
        new_fingerprint=new_fingerprint_for_vae,
    )
    precomputed_dataset = concatenate_datasets(
        [train_dataset_with_embeddings, train_dataset_with_vae.remove_columns(['path', 'width', 'height', 'aspect_ratio', 'category', 'no','caption'])], axis=1
    )
    precomputed_dataset = precomputed_dataset.with_transform(preprocess_train)


train_dataloader = torch.utils.data.DataLoader(
    precomputed_dataset,
    shuffle=True,
    collate_fn=collate_fn,
    batch_size=args["train_batch_size"],
    num_workers=args["dataloader_num_workers"],
)

del compute_vae_encodings_fn, compute_embeddings_fn,vae
if(args.get("train_text_encoder") is not True):
  del text_encoders,text_encoder_one,text_encoder_two, tokenizers,
gc.collect()
torch.cuda.empty_cache()

"""test out the dataset"""

next(iter(train_dataloader))

def compute_time_ids(original_size, crops_coords_top_left):
    # Adapted from pipeline.StableDiffusionXLPipeline._get_add_time_ids
    target_size = (args["resolutionH"], args["resolutionW"])
    add_time_ids = list(original_size + crops_coords_top_left + target_size)
    add_time_ids = torch.tensor([add_time_ids])
    add_time_ids = add_time_ids.to(accelerator.device, dtype=weight_dtype)
    return add_time_ids

if not args.get("train_text_encoder") ==True:
    tokenizers = [tokenizer_one, tokenizer_two]
    text_encoders = [text_encoder_one, text_encoder_two]

    def compute_text_embeddings(prompt, text_encoders, tokenizers):
        with torch.no_grad():
            prompt_embeds, pooled_prompt_embeds = encode_prompt(text_encoders, tokenizers, prompt)
            prompt_embeds = prompt_embeds.to(accelerator.device)
            pooled_prompt_embeds = pooled_prompt_embeds.to(accelerator.device)
        return prompt_embeds, pooled_prompt_embeds

# If no type of tuning is done on the text_encoder and custom instance prompts are NOT
# provided (i.e. the --instance_prompt is used for all images), we encode the instance prompt once to avoid
# the redundant encoding.
if not args.get("train_text_encoder") and not train_dataset.custom_instance_prompts:
    instance_prompt_hidden_states, instance_pooled_prompt_embeds = compute_text_embeddings(
        args["instance_prompt"], text_encoders, tokenizers
    )

# Handle class prompt for prior-preservation.
if args.get("with_prior_preservation"):
    if not args["train_text_encoder"]:
        class_prompt_hidden_states, class_pooled_prompt_embeds = compute_text_embeddings(
            args["class_prompt"], text_encoders, tokenizers
        )

# Clear the memory here
if not args.get("train_text_encoder") and not train_dataset.custom_instance_prompts:
    del tokenizers, text_encoders
    gc.collect()
    if torch.cuda.is_available():
        torch.cuda.empty_cache()

# If custom instance prompts are NOT provided (i.e. the instance prompt is used for all images),
# pack the statically computed variables appropriately here. This is so that we don't
# have to pass them to the dataloader.

# if not train_dataset.custom_instance_prompts:
#     if not args["train_text_encoder"]:
#         prompt_embeds = instance_prompt_hidden_states
#         unet_add_text_embeds = instance_pooled_prompt_embeds
#         if args.get("with_prior_preservation"):
#             prompt_embeds = torch.cat([prompt_embeds, class_prompt_hidden_states], dim=0)
#             unet_add_text_embeds = torch.cat([unet_add_text_embeds, class_pooled_prompt_embeds], dim=0)
#     # if we're optimizing the text encoder (both if instance prompt is used for all images or custom prompts) we need to tokenize and encode the
#     # batch prompts on all training steps
#     else:
#         tokens_one = tokenize_prompt(tokenizer_one, args["instance_prompt"])
#         tokens_two = tokenize_prompt(tokenizer_two, args["instance_prompt"])
#         if args.get("with_prior_preservation"):
#             class_tokens_one = tokenize_prompt(tokenizer_one, args["class_prompt"])
#             class_tokens_two = tokenize_prompt(tokenizer_two, args["class_prompt"])
#             tokens_one = torch.cat([tokens_one, class_tokens_one], dim=0)
#             tokens_two = torch.cat([tokens_two, class_tokens_two], dim=0)

# Scheduler and math around the number of training steps.
overrode_max_train_steps = False
num_update_steps_per_epoch = math.ceil(len(train_dataloader) / args["gradient_accumulation_steps"])
if args["max_train_steps"] is None:
    args["max_train_steps"] = args["num_train_epochs"] * num_update_steps_per_epoch
    overrode_max_train_steps = True

lr_scheduler = get_scheduler(
    args["lr_scheduler"],
    optimizer=optimizer,
    num_warmup_steps=args["lr_warmup_steps"] * accelerator.num_processes,
    num_training_steps=args["max_train_steps"] * accelerator.num_processes,
    num_cycles=args["lr_num_cycles"],
    power=args["lr_power"],
)

# Prepare everything with our `accelerator`.
if args.get("train_text_encoder") == True:
    unet, text_encoder_one, text_encoder_two, optimizer, train_dataloader, lr_scheduler = accelerator.prepare(
        unet, text_encoder_one, text_encoder_two, optimizer, train_dataloader, lr_scheduler
    )
else:
    unet, optimizer, train_dataloader, lr_scheduler = accelerator.prepare(
        unet, optimizer, train_dataloader, lr_scheduler
    )

# We need to recalculate our total training steps as the size of the training dataloader may have changed.
num_update_steps_per_epoch = math.ceil(len(train_dataloader) / args["gradient_accumulation_steps"])
if overrode_max_train_steps:
    args["max_train_steps"] = args["num_train_epochs"] * num_update_steps_per_epoch
# Afterwards we recalculate our number of training epochs
args["num_train_epochs"] = math.ceil(args["max_train_steps"] / num_update_steps_per_epoch)

# We need to initialize the trackers we use, and also store our configuration.
# The trackers initializes automatically on the main process.
if accelerator.is_main_process:
    tracker_name = (
        "dreambooth-lora-sd-xl"
        if "playground" not in args["pretrained_model_name_or_path"]
        else "dreambooth-lora-playground"
    )
    accelerator.init_trackers(tracker_name, args)

args['max_train_steps'] = 6000
args["num_train_epochs"]=80

"""train"""

# Train!
total_batch_size = args["train_batch_size"] * accelerator.num_processes * args["gradient_accumulation_steps"]

logger.info("***** Running training *****")
logger.info(f"  Num examples = {len(train_dataset)}")
logger.info(f"  Num batches each epoch = {len(train_dataloader)}")
logger.info(f"  Num Epochs = {args['num_train_epochs']}")
logger.info(f"  Instantaneous batch size per device = {args['train_batch_size']}")
logger.info(f"  Total train batch size (w. parallel, distributed & accumulation) = {total_batch_size}")
logger.info(f"  Gradient Accumulation steps = {args['gradient_accumulation_steps']}")
logger.info(f"  Total optimization steps = {args['max_train_steps']}")
global_step = 0
first_epoch = 0


initial_global_step = 0

progress_bar = tqdm(
    range(0, args["max_train_steps"]),
    initial=initial_global_step,
    desc="Steps",
    # Only show the progress bar once on each machine.
    disable=not accelerator.is_local_main_process,
)

def get_sigmas(timesteps, n_dim=4, dtype=torch.float32):
    sigmas = noise_scheduler.sigmas.to(device=accelerator.device, dtype=dtype)
    schedule_timesteps = noise_scheduler.timesteps.to(accelerator.device)
    timesteps = timesteps.to(accelerator.device)

    step_indices = [(schedule_timesteps == t).nonzero().item() for t in timesteps]

    sigma = sigmas[step_indices].flatten()
    while len(sigma.shape) < n_dim:
        sigma = sigma.unsqueeze(-1)
    return sigma


for epoch in range(first_epoch, args["num_train_epochs"]):
    unet.train()

    if args.get("train_text_encoder") is True:
        text_encoder_one.train()
        text_encoder_two.train()

        # set top parameter requires_grad = True for gradient checkpointing works
        accelerator.unwrap_model(text_encoder_one).text_model.embeddings.requires_grad_(True)
        accelerator.unwrap_model(text_encoder_two).text_model.embeddings.requires_grad_(True)

    for step, batch in enumerate(train_dataloader):
        with accelerator.accumulate(unet):
            model_input = batch["model_input"].to(accelerator.device)
            # Sample noise that we'll add to the latents
            noise = torch.randn_like(model_input)
            bsz = model_input.shape[0]

            # Sample a random timestep for each image
            if not args.get("do_edm_style_training"):
                timesteps = torch.randint(
                    0, noise_scheduler.config.num_train_timesteps, (bsz,), device=model_input.device
                )
                timesteps = timesteps.long()
            else:
                # in EDM formulation, the model is conditioned on the pre-conditioned noise levels
                # instead of discrete timesteps, so here we sample indices to get the noise levels
                # from `scheduler.timesteps`
                indices = torch.randint(0, noise_scheduler.config.num_train_timesteps, (bsz,))
                timesteps = noise_scheduler.timesteps[indices].to(device=model_input.device)

            # Add noise to the model input according to the noise magnitude at each timestep
            # (this is the forward diffusion process)
            noisy_model_input = noise_scheduler.add_noise(model_input, noise, timesteps)
            # For EDM-style training, we first obtain the sigmas based on the continuous timesteps.
            # We then precondition the final model inputs based on these sigmas instead of the timesteps.
            # Follow: Section 5 of https://arxiv.org/abs/2206.00364.
            if args.get("do_edm_style_training") is True:
                sigmas = get_sigmas(timesteps, len(noisy_model_input.shape), noisy_model_input.dtype)
                if "EDM" in scheduler_type:
                    inp_noisy_latents = noise_scheduler.precondition_inputs(noisy_model_input, sigmas)
                else:
                    inp_noisy_latents = noisy_model_input / ((sigmas**2 + 1) ** 0.5)

            # time ids
            add_time_ids = torch.cat(
                [
                    compute_time_ids(original_size=s, crops_coords_top_left=c)
                    for s, c in zip(batch["original_sizes"], batch["crop_top_lefts"])
                ]
            )

            # Calculate the elements to repeat depending on the use of prior-preservation and custom captions.
            if not args.get("train_text_encoder") ==None:
                elems_to_repeat_text_embeds = bsz // 2 if args.get("with_prior_preservation") else bsz
            else:
                elems_to_repeat_text_embeds = 1

            # Predict the noise residual
            dontTRainTextEcoder = False
            if dontTRainTextEcoder:
	            unet_added_conditions = {"time_ids": add_time_ids}
	            prompt_embeds = batch["prompt_embeds"].to(accelerator.device, dtype=weight_dtype)
	            pooled_prompt_embeds = batch["pooled_prompt_embeds"].to(accelerator.device)
	            unet_added_conditions.update({"text_embeds": pooled_prompt_embeds})
	            model_pred = unet(
	                noisy_model_input,
	                timesteps,
	                prompt_embeds,
	                added_cond_kwargs=unet_added_conditions,
	                return_dict=False,
	            )[0]
            else:
              # aici
	            unet_added_conditions = {"time_ids": add_time_ids}
	            prompt_embeds = batch["prompt_embeds"].to(accelerator.device, dtype=weight_dtype)
	            pooled_prompt_embeds = batch["pooled_prompt_embeds"].to(accelerator.device)
	            unet_added_conditions.update(
	                {"text_embeds": pooled_prompt_embeds.repeat(elems_to_repeat_text_embeds, 1)})
	            prompt_embeds_input = prompt_embeds.repeat(elems_to_repeat_text_embeds, 1, 1)
	            model_pred = unet(
	                        inp_noisy_latents if args.get("do_edm_style_training") else noisy_model_input,
	                        timesteps,
	                        prompt_embeds_input,
	                        added_cond_kwargs=unet_added_conditions,
	                        return_dict=False,
	            )[0]
            weighting = None
            if args.get("do_edm_style_training"):
                # Similar to the input preconditioning, the model predictions are also preconditioned
                # on noised model inputs (before preconditioning) and the sigmas.
                # Follow: Section 5 of https://arxiv.org/abs/2206.00364.
                if "EDM" in scheduler_type:
                    model_pred = noise_scheduler.precondition_outputs(noisy_model_input, model_pred, sigmas)
                else:
                    if noise_scheduler.config.prediction_type == "epsilon":
                        model_pred = model_pred * (-sigmas) + noisy_model_input
                    elif noise_scheduler.config.prediction_type == "v_prediction":
                        model_pred = model_pred * (-sigmas / (sigmas**2 + 1) ** 0.5) + (
                            noisy_model_input / (sigmas**2 + 1)
                        )
                # We are not doing weighting here because it tends result in numerical problems.
                # See: https://github.com/huggingface/diffusers/pull/7126#issuecomment-1968523051
                # There might be other alternatives for weighting as well:
                # https://github.com/huggingface/diffusers/pull/7126#discussion_r1505404686
                if "EDM" not in scheduler_type:
                    weighting = (sigmas**-2.0).float()

            # Get the target for loss depending on the prediction type
            if noise_scheduler.config.prediction_type == "epsilon":
                target = model_input if args.get("do_edm_style_training") else noise
            elif noise_scheduler.config.prediction_type == "v_prediction":
                target = (
                    model_input
                    if args.get("do_edm_style_training")
                    else noise_scheduler.get_velocity(model_input, noise, timesteps)
                )
            else:
                raise ValueError(f"Unknown prediction type {noise_scheduler.config.prediction_type}")

            if args.get("with_prior_preservation"):
                # Chunk the noise and model_pred into two parts and compute the loss on each part separately.
                model_pred, model_pred_prior = torch.chunk(model_pred, 2, dim=0)
                target, target_prior = torch.chunk(target, 2, dim=0)

                # Compute prior loss
                if weighting is not None:
                    prior_loss = torch.mean(
                        (weighting.float() * (model_pred_prior.float() - target_prior.float()) ** 2).reshape(
                            target_prior.shape[0], -1
                        ),
                        1,
                    )
                    prior_loss = prior_loss.mean()
                else:
                    prior_loss = F.mse_loss(model_pred_prior.float(), target_prior.float(), reduction="mean")

            if args["snr_gamma"] is None:
                if weighting is not None:
                    loss = torch.mean(
                        (weighting.float() * (model_pred.float() - target.float()) ** 2).reshape(
                            target.shape[0], -1
                        ),
                        1,
                    )
                    loss = loss.mean()
                else:
                    loss = F.mse_loss(model_pred.float(), target.float(), reduction="mean")
            else:
                # Compute loss-weights as per Section 3.4 of https://arxiv.org/abs/2303.09556.
                # Since we predict the noise instead of x_0, the original formulation is slightly changed.
                # This is discussed in Section 4.2 of the same paper.
                snr = compute_snr(noise_scheduler, timesteps)
                base_weight = (
                    torch.stack([snr, args["snr_gamma"] * torch.ones_like(timesteps)], dim=1).min(dim=1)[0] / snr
                )

                if noise_scheduler.config.prediction_type == "v_prediction":
                    # Velocity objective needs to be floored to an SNR weight of one.
                    mse_loss_weights = base_weight + 1
                else:
                    # Epsilon and sample both use the same loss weights.
                    mse_loss_weights = base_weight

                loss = F.mse_loss(model_pred.float(), target.float(), reduction="none")
                loss = loss.mean(dim=list(range(1, len(loss.shape)))) * mse_loss_weights
                loss = loss.mean()

            if args.get("with_prior_preservation"):
                # Add the prior loss to the instance loss.
                loss = loss + args["prior_loss_weight"] * prior_loss

            accelerator.backward(loss)
            if accelerator.sync_gradients:
                params_to_clip = (
                    itertools.chain(unet_lora_parameters, text_lora_parameters_one, text_lora_parameters_two)
                    if args.get("train_text_encoder") is not None
                    else unet_lora_parameters
                )
                accelerator.clip_grad_norm_(params_to_clip, args["max_grad_norm"])

            optimizer.step()
            lr_scheduler.step()
            optimizer.zero_grad()

        # Checks if the accelerator has performed an optimization step behind the scenes
        if accelerator.sync_gradients:
            progress_bar.update(1)
            global_step += 1

            if accelerator.is_main_process:
                if global_step % args["checkpointing_steps"] == 0:
                    # _before_ saving state, check if this save would set us over the `checkpoints_total_limit`
                    if args.get("checkpoints_total_limit") is not None:
                        checkpoints = os.listdir(args["output_dir"])
                        checkpoints = [d for d in checkpoints if d.startswith("checkpoint")]
                        checkpoints = sorted(checkpoints, key=lambda x: int(x.split("-")[1]))

                        # before we save the new checkpoint, we need to have at _most_ `checkpoints_total_limit - 1` checkpoints
                        if len(checkpoints) >= args.get("checkpoints_total_limit"):
                            num_to_remove = len(checkpoints) - args.get("checkpoints_total_limit") + 1
                            removing_checkpoints = checkpoints[0:num_to_remove]

                            logger.info(
                                f"{len(checkpoints)} checkpoints already exist, removing {len(removing_checkpoints)} checkpoints"
                            )
                            logger.info(f"removing checkpoints: {', '.join(removing_checkpoints)}")

                            for removing_checkpoint in removing_checkpoints:
                                removing_checkpoint = os.path.join(args["output_dir"], removing_checkpoint)
                                shutil.rmtree(removing_checkpoint)

                    save_path = os.path.join(args["output_dir"], f"checkpoint-{global_step}")
                    accelerator.save_state(save_path)
                    logger.info(f"Saved state to {save_path}")

        logs = {"loss": loss.detach().item(), "lr": lr_scheduler.get_last_lr()[0]}
        progress_bar.set_postfix(**logs)
        accelerator.log(logs, step=global_step)

        if global_step >= args["max_train_steps"]:
            break

    if accelerator.is_main_process:
        if args.get("validation_prompt") is not None and epoch % args.get("validation_epochs") == 0:
            # create pipeline
            if   args.get("train_text_encoder") is not None:
                text_encoder_one = text_encoder_cls_one.from_pretrained(
                    args["pretrained_model_name_or_path"],
                    subfolder="text_encoder",


                )
                text_encoder_two = text_encoder_cls_two.from_pretrained(
                    args["pretrained_model_name_or_path"],
                    subfolder="text_encoder_2",


                )
            pipeline = StableDiffusionXLPipeline.from_pretrained(
                args["pretrained_model_name_or_path"],
                vae=vae,
                text_encoder=accelerator.unwrap_model(text_encoder_one),
                text_encoder_2=accelerator.unwrap_model(text_encoder_two),
                unet=accelerator.unwrap_model(unet),


                torch_dtype=weight_dtype,
            )
            pipeline_args = {"prompt": args["validation_prompt"]}

            images = log_validation(
                pipeline,
                args,
                accelerator,
                pipeline_args,
                epoch,
                torch_dtype=weight_dtype,
            )

# Save the lora layers
accelerator.wait_for_everyone()
if accelerator.is_main_process:
    unet = unwrap_model(unet)
    unet = unet.to(torch.float32)
    unet_lora_layers = convert_state_dict_to_diffusers(get_peft_model_state_dict(unet))

    if args.get("train_text_encoder") is not None :
        text_encoder_one = unwrap_model(text_encoder_one)
        text_encoder_lora_layers = convert_state_dict_to_diffusers(
            get_peft_model_state_dict(text_encoder_one.to(torch.float32))
        )
        text_encoder_two = unwrap_model(text_encoder_two)
        text_encoder_2_lora_layers = convert_state_dict_to_diffusers(
            get_peft_model_state_dict(text_encoder_two.to(torch.float32))
        )
    else:
        text_encoder_lora_layers = None
        text_encoder_2_lora_layers = None

    StableDiffusionXLPipeline.save_lora_weights(
        save_directory=args["output_dir"],
        unet_lora_layers=unet_lora_layers,
        text_encoder_lora_layers=text_encoder_lora_layers,
        text_encoder_2_lora_layers=text_encoder_2_lora_layers,
    )
    if args.get("output_kohya_format") is not None:
        lora_state_dict = load_file(f"{args['output_dir']}/pytorch_lora_weights.safetensors")
        peft_state_dict = convert_all_state_dict_to_peft(lora_state_dict)
        kohya_state_dict = convert_state_dict_to_kohya(peft_state_dict)
        save_file(kohya_state_dict, f"{args['output_dir']}/pytorch_lora_weights_kohya.safetensors")

    # Final inference
    # Load previous pipeline
    vae = AutoencoderKL.from_pretrained(
        vae_path,
        subfolder="vae" if args["pretrained_vae_model_name_or_path"] is None else None,


        torch_dtype=weight_dtype,
    )
    pipeline = StableDiffusionXLPipeline.from_pretrained(
        args["pretrained_model_name_or_path"],
        vae=vae,


        torch_dtype=weight_dtype,
    )

    # load attention processors
    pipeline.load_lora_weights(args["output_dir"])

    # run inference
    images = []
    if args.get("validation_prompt") is not None and args.get("num_validation_images") is not None:
        pipeline_args = {"prompt": args.get("validation_prompt"), "num_inference_steps": 25}
        images = log_validation(
            pipeline,
            args,
            accelerator,
            pipeline_args,
            epoch,
            is_final_validation=True,
            torch_dtype=weight_dtype,
        )
accelerator.end_training()

# Commented out IPython magic to ensure Python compatibility.
# %cp -r /content/Stable_DIFF_Gabi_XL/pytorch_lora_weights.safetensors /content/drive/MyDrive/AiModels/stableDiff/LORA_AND_ENCODER

# Commented out IPython magic to ensure Python compatibility.
from google.colab import drive
drive.mount('/content/drive/')
# %cp -r content/drive/MyDrive/AiModels/stableDiff/LORA_AND_ENCODER/ /content/sdxl-naruto-model/

device = 'mps' if torch.backends.mps.is_available() else 'cuda' if torch.cuda.is_available() else 'cpu'

# unet = UNet2DConditionModel.from_pretrained(
#     "/content/sdxl-naruto-model/unet"
# )


from diffusers import StableDiffusionXLImg2ImgPipeline



vae_path = (
args["pretrained_model_name_or_path"]
if args["pretrained_vae_model_name_or_path"] is None
else args["pretrained_vae_model_name_or_path"]
)
print(vae_path)

weight_dtype = torch.float32
vae = AutoencoderKL.from_pretrained(
    vae_path,
    subfolder="vae" if  not "pretrained_vae_model_name_or_path" in args   else None,
    torch_dtype=weight_dtype,
)
pipeline = StableDiffusionXLPipeline.from_pretrained(
    args["pretrained_model_name_or_path"],
    vae=vae,
    torch_dtype=weight_dtype,
)
refiner = StableDiffusionXLImg2ImgPipeline.from_pretrained(
    "stabilityai/stable-diffusion-xl-refiner-1.0", torch_dtype=torch.float32, variant="fp16", use_safetensors=True
)
# refiner = StableDiffusionXLPipeline.from_pretrained(
#     "stabilityai/stable-diffusion-xl-refiner-1.0",
#     # text_encoder=pipeline.text_encoder,
#     # text_encoder_2=pipeline.text_encoder_2,
#     # vae=pipeline.vae,
#     torch_dtype=torch.float32,
#     use_safetensors=True,
#     variant="fp16",
# )

# load attention processors

# Commented out IPython magic to ensure Python compatibility.
# %cp -r /content/drive/MyDrive/AiModels/stableDiff/LORA_AND_ENCODER /content/Stable_DIFF_Gabi_XL/

pipeline.load_lora_weights("/content/Stable_DIFF_Gabi_XL/")


pipeline = pipeline.to(device)
refiner = refiner.to(device)

args["seed"] = 0
generator = torch.Generator(device=device).manual_seed(args["seed"]) if "seed" in args else None
prompt = "@potKitten@sandyinlace face"
autocast_ctx = torch.autocast(device)
with autocast_ctx:

  image = pipeline(prompt, num_inference_steps=25, generator=generator,height=1280,width=960).images[0]
  target_size = (1280, 960)
  original_size = (1280, 960)
  crops_coords_top_left = (0, 0)
  add_time_ids = list(original_size + crops_coords_top_left + target_size)
  add_time_ids = torch.tensor([add_time_ids])
  add_time_ids.unsqueeze(1)
  add_time_ids = add_time_ids
  high_noise_frac = 0.8
  # image = refiner(
  #     prompt=prompt,
  #     num_inference_steps=50,
  #     denoising_start=high_noise_frac,
  #     image=image,
  #     # timesteps=add_time_ids
  # ).images[0]

#   image = pipeline('jasminjae poza 13', num_inference_steps=999,height=1280,
#         width=960 ).images[0]

# # image = pipeline('jasminejae ', num_inference_steps=999)
image

high_noise_frac = 0.8
  image = refiner(
      prompt=prompt,
      num_inference_steps=15,
      denoising_start=high_noise_frac,
      image=image,
      # timesteps=add_time_ids
  ).images[0]

image